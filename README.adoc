Mining Camp
===========
:toc:

Easy automated configuration and deployment of Minecraft servers on AWS spot
instances.

== Setup

Start by checking out this repository, and navigating to your checkout-out
directory. Sample bash commands provided are from the root directory unless
otherwise noted and .

=== Requirements

You'll need to download and install the following requirements (versions I
build and tested with are in parenthesis):

* `pip` (v9.0.1)
* `terraform` (0.10.2)

You'll need an appropriate version of the JDK/JVM to run the server locally at
least once, allowing it to generate the necessary configuration files.

You'll also need a fully configured AWS developer account, with an access key
and secret pair. You'll need to configure those on your system in the following
step, if you haven't already.

=== Configuration

==== AWS

You'll need your AWS credentials available for most of these operations, under
the `minecraft` profile. `~/.aws/credentials` will look like:

```
[minecraft]
aws_access_key_id = <your_access_key_here>
aws_secret_access_key = <your_secret_key_here>
```

If you have more than one AWS profile, you'll need to set the `AWS_PROFILE`
environment variable with `export AWS_PROFILE=minecraft` for the `aws` commands
below to work.

The one configuration piece in the AWS console that will need to be done by
hand is creation of an elastic IP. In the AWS console, do the following:

1. Enter the EC2 service.
2. Click on _Elastic IPs_, under the _NETWORK & SECURITY_ menu on the left-hand
side of the screen.
3. Click _Allocate new address_.
4. Leave the scope as "VPC", and click close.
5. You should see your new elastic IP in the list. Save the _Allocation ID_ for
later use in the Ansible configuration.

Once a server has been spun up, this elastic IP will be attached to it. Note
that allocated elastic IPs are included in the price of a running instance, but
you will be billed for any un-assigned EIPs by the hour. For this reason, if
you plan to stop your Minecraft server for long periods of time, be sure to
delete your EIPs and create new ones when you're ready to begin hosting again.

==== Virtual Environment & Requirements

Using pip, install the necessary Python requirements:

```
$ mkvirtualenv minecraft
(minecraft) $ pip install -r requirements.txt
```

==== Terraform

Terraform allows you to easily setup EC2 and S3 to match your needs. You'll
need to do some minor configuration in `terraform/variables.tf`. The only
setting that absolutely needs to be changed is the `bucket_name`, which should
match the name of the S3 bucket you'll be using. You'll also need to update the
`aws_region`, if you're not running in the default region ('us-east-1').

Then, from the root directory of your modified `mining-camp` checkout run:

```
./terraform apply terraform/
```

Once this has successfully completed, your AWS configuration is complete.
Unless you change terraform settings or need to shutdown your server you won't
need to run this again.

==== Ansible

Ansible is used to configure the settings on the EC2 instance itself, once it's
up and running. Open `ansible/group_vars/all` in your favourite editor, and set
the following:

* `aws_region` - Only if using a region other than the default ('us-east-1').
* `minecraft_eip_alloc_id` - Use the allocation ID of the elastic IP you
created above, like 'eipalloc-06237b35'.
* `s3_bucket` - The name of the bucket you'll be using. Should match the bucket
name you set in the Terraform config.
* `server_name` - Each server has its own directory in your S3 bucket,
containing both the server archive and all the server's periodic backups.
* `server_file` - Name of the server archive containing the Minecraft server.
More details on creating this archive are below.

Update `ansible/files/prospector.cfg` with the same settings, as well as with
the _world_name_ you'll be using.

==== Minecraft Server Archive

You'll need to create a Minecraft server archive to be pulled onto your
instance each time the box is spun up. In this example, I'll be creating an
archive for my Feed the Beast server named `daftcyborg`.

```
$ # Create a base directory named after your server name
$ mkdir daftcyborg
$ cd daftcyborg

$ # Get your base server pack. In my case, I've already downloaded the FTB server
$ ls
FTBRevelationServer_1.0.0.zip
$ unzip FTBRevelationServer_1.0.0.zip

$ # Install the server requirements
$ sh ./FTBInstall.sh
```

Open the EULA, and agree (or don't) to the terms and conditions.

Launch the server once, and wait for it to complete. This will generate the
world base, and any settings and properties files necessary. Quit the server,
and do the following as desired:

* Remove the `world` directory, which is the world directory name used by
default and which will (assuming you update the `server.properties` file) be
named differently when your server is run.
* Edit `server.properties` as desired. It is important that the _server-port_
be left as _25565_, otherwise you'll need to adjust the Terraform
configuration. Fields I recommend changing are _level-name_, _level-seed_, and
_motd_.
* Add yourself and any other players desired to `ops.json`.
* Update `server-icon.png` to a custom icon.

Copy server.properties to `ansible/files/server.properties`, which Ansible will
install every time over the top of the properties file in the archive, allowing
easy configuration changes.

Now, clean up your leftover base archive, since you don't need it anymore:

```
$ rm FTBRevelationServer_1.0.0.zip
```

Navigate up a level, and create a gzipped tarball with the same name as the
`server_file` name in `ansible/group_vars/all`:

```
$ cd ..
$ tar -cvzf daftcyborg-server-12-20-2017.tgz daftcyborg/
```

Lastly, push the archive to S3:

```
$ # The parameterized command is 'aws s3 cp <server_file> s3://<bucket_name>/<server_name>/'
$ # My version looks like:
$ aws s3 cp daftcyborg-server-12-20-2017.tgz s3://josh-minecraft/daftcyborg/
```

=== Execution

Up until now, everything in EC2 is created but no instances are running. To
launch an instance, open `terraform/main.tf` and edit the _minecraft_
`aws_autoscaling_group`'s `desired_capacity` from _0_ to _1_. Then re-run
terraform, like:

```
./terraform apply terraform/
```

Now you have an instance running, but it hasn't been set up to run our server.
Jump to the `ansible` directory, and run the playbook to configure the instance
and launch the minecraft server:

```
cd ansible
ansible-playbook -i ec2.py --private-key=~/.ssh/aws -u ubuntu -c ssh minecraft.yml
```

The `ec2.py` inventory file should automatically pick up your new instance
after one or two attempts. On my setup, the Paramiko Python library Ansible
uses by default ran into errors when attempting to gather facts from the server,
so I use `-c ssh` instead.

Sometimes the NVMe mount will succeed, but the subsequent folder creation will
fail due to the mount not being available fast enough. If this occurs, simply
re-run.

== Troubleshooting

If you want to connect to your instance directly, use the key-pair you set up
initially to SSH into the instance:

```
ssh -i ~/.ssh/aws ubuntu@<elastic_ip>
```

Once you're on the box, you can attach to the tmux session the server has been
started in:

```
tmux attach-session -t minecraft
```

== TODO

Currently uses an auto-scaling group, rather than a launch configuration. I'd
like to port it over to use the newer launch configurations instead.
