Mining Camp
===========
:toc:
:toc-placement: preamble
:toclevels: 3

Easy automated configuration and deployment of Minecraft servers on AWS spot
instances, featuring automatic backups and restoration using S3.

== Setup

Start by checking out this repository, and navigating to your checkout-out
directory. Sample bash commands provided are from the root directory unless
otherwise noted and .

=== Requirements

You'll need to download and install the following requirements (versions I
build and tested with are in parenthesis):

* `pip` (v9.0.1)
* `terraform` (0.10.2)

You'll need an appropriate version of the JDK/JVM to run the server locally at
least once, allowing it to generate the necessary configuration files.

You'll also need a fully configured AWS developer account, as you'll be using
the console extensively in the next step.

=== Configuration

==== AWS

Most of the heavy lifting in AWS is done by terraform. However, a few steps
need to be taken before using terraform.

===== Credentials

You'll need your AWS credentials available for most of these operations, under
the `minecraft` profile. `~/.aws/credentials` will look like:

```
[minecraft]
aws_access_key_id = <your_access_key_here>
aws_secret_access_key = <your_secret_key_here>
```

If you have more than one AWS profile, you'll need to set the `AWS_PROFILE`
environment variable with `export AWS_PROFILE=minecraft` for the `aws` commands
below to work.

===== Key Pair

You'll need a key pair for accessing your instance. Generate a public-private
key pair. As an example, you can do this with `ssh-keygen`:

```
ssh-keygen -t rsa -b 4096 -C "AWS"
```

In the EC2 console, select _Import Key Pair_ on the
_NETWORK & SECURITY -> Key Pairs_ page. Upload your public key, and name it
"aws-public". The launch configuration Terraform creates includes this key,
allowing SSH access to Ansible (and for troubleshooting!)

===== Elastic IP Creation

You'll need to create an elastic IP for association with your instance,
providing a convenient public-facing IP. In the AWS console, do the following:

1. Enter the EC2 service.
2. Click on _Elastic IPs_, under the _NETWORK & SECURITY_ menu on the left-hand
side of the screen.
3. Click _Allocate new address_.
4. Leave the scope as "VPC", and click close.
5. You should see your new elastic IP in the list. Save the _Allocation ID_ for
later use in the Ansible configuration.

Once a server has been spun up, this elastic IP will be attached to it. Note
that allocated elastic IPs are included in the price of a running instance, but
you will be billed for any un-assigned EIPs by the hour. For this reason, if
you plan to stop your Minecraft server for long periods of time, be sure to
delete your EIPs and create new ones when you're ready to begin hosting again.

==== Virtual Environment & Requirements

Using pip, install the necessary Python requirements. This installs Ansible,
the AWS command-line interface, and libraries required for interacting with AWS
programmatically.

```
$ mkvirtualenv minecraft
(minecraft) $ pip install -r requirements.txt
```

==== Terraform

Terraform allows you to easily setup EC2 and S3 to match your needs. You'll
need to do some minor configuration in `terraform/variables.tf`. The only
setting that absolutely needs to be changed is the `bucket_name`, which should
match the name of the S3 bucket you'll be using. You'll also need to update the
`aws_region`, if you're not running in the default region ('us-east-1').

Then, from the root directory of your modified `mining-camp` checkout run:

```
./terraform apply terraform/
```

Once this has successfully completed, your AWS configuration is complete.
Unless you change your AWS configuration, you won't need to run this again.

==== Ansible

Ansible is used to configure the settings on the EC2 instance itself, once it's
up and running. Open `ansible/group_vars/all` in your favourite editor, and set
the following:

* `aws_region` - Only if using a region other than the default ('us-east-1').
* `minecraft_eip_alloc_id` - Use the allocation ID of the elastic IP you
created above, like 'eipalloc-06237b35'.
* `s3_bucket` - The name of the bucket you'll be using. Should match the bucket
name you set in the Terraform config.
* `server_name` - Each server has its own directory in your S3 bucket,
containing both the server archive and all the server's periodic backups.
* `server_file` - Name of the server archive containing the Minecraft server.
More details on creating this archive are below.

Update `ansible/files/prospector.cfg` with the same settings, as well as with
the _world_name_ you'll be using.

Lastly, update `ansible/ec2.ini`'s `regions` entry with the AWS region you're
using. You can set this to _all_, but the dynamic EC2 entry script will take
longer.

==== Minecraft Server Archive

You'll need to create a Minecraft server archive to be pulled onto your
instance each time the box is spun up. In this example, I'll be creating an
archive for my Feed the Beast server named `daftcyborg`.

```
$ # Create a base directory named after your server name
$ mkdir daftcyborg
$ cd daftcyborg

$ # Get your base server pack. In my case, I've already downloaded the FTB server
$ ls
FTBRevelationServer_1.0.0.zip
$ unzip FTBRevelationServer_1.0.0.zip

$ # Install the server requirements
$ sh ./FTBInstall.sh
```

Open the EULA, and agree (or don't) to the terms and conditions.

Launch the server once, and wait for it to complete. This will generate the
world base, and any settings and properties files necessary. Quit the server,
and do the following as desired:

* Remove the `world` directory, which is the world directory name used by
default and which will (assuming you update the `server.properties` file) be
named differently when your server is run.
* Edit `server.properties` as desired. It is important that the _server-port_
be left as _25565_, otherwise you'll need to adjust the Terraform
configuration. Fields I recommend changing are _level-name_, _level-seed_, and
_motd_.
* Add yourself and any other players desired to `ops.json`.
* Update `server-icon.png` to a custom icon.

Copy server.properties to `ansible/files/server.properties`, which Ansible will
install every time over the top of the properties file in the archive, allowing
easy configuration changes.

Now, clean up your leftover base archive, since you don't need it anymore:

```
$ rm FTBRevelationServer_1.0.0.zip
```

Navigate up a level, and create a gzipped tarball with the same name as the
`server_file` name in `ansible/group_vars/all`:

```
$ cd ..
$ tar -cvzf daftcyborg-server-12-20-2017.tgz daftcyborg/
```

Lastly, push the archive to S3:

```
$ # The parameterized command is 'aws s3 cp <server_file> s3://<bucket_name>/<server_name>/'
$ # My version looks like:
$ aws s3 cp daftcyborg-server-12-20-2017.tgz s3://josh-minecraft/daftcyborg/
```

== Spot Instance Interactions

=== Server Launch & Provision

Jump to the `ansible` directory, and run the playbook to configure the instance
and launch the minecraft server:

```
cd ansible
ansible-playbook -i ec2.py --private-key=~/.ssh/aws -u ubuntu -c ssh start.yml
```

The `ec2.py` inventory file should automatically pick up your new instance.

NOTE: On my setup, the Paramiko library Ansible uses by default ran into errors
when attempting to gather facts from the server, so I had to use `-c ssh`
instead.

=== Server Shutdown

Shutting down your server is just as easy as starting it:

```
cd ansible
ansible-playbook -i ec2.py --private-key=~/.ssh/aws -u ubuntu -c ssh stop.yml
```

When this playbook finishes, your instance will be gone, but the state of the
server will have been preserved and pushed to S3, ready for the next time you
launch it.

== Tests

Tests are currently available for the Prospector tool. You'll need to install
the requirements in the test directory in order to run them. From the root,
with your virtual environment active:

```
(minecraft) $ pip install -r utilities/tests/requirements.txt
```

Now you can launch the test suite:

```
(minecraft) $ python -m unittest -v utilities.tests.test_prospector
```

== Todo

Currently uses an auto-scaling group, rather than a launch configuration. I'd
like to port it over to use the newer launch configurations instead.

Create a configuration script that can take user input and populate the
configuration files as needed. This would make this so painless!
